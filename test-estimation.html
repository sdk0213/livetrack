<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ì˜ˆìƒ ìœ„ì¹˜ ê³„ì‚° í…ŒìŠ¤íŠ¸ - ì¶˜ì²œë§ˆë¼í†¤</title>
  <style>
    body { margin: 0; padding: 0; font-family: sans-serif; background: #0e111a; color: #e0e6ed; }
    .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
    h1 { color: #5cc8ff; margin-bottom: 20px; }
    .controls { background: #1a1f2e; padding: 20px; border-radius: 10px; margin-bottom: 20px; }
    label { display: block; margin: 10px 0 5px 0; font-weight: bold; color: #5cc8ff; }
    input, select { padding: 8px; border: 1px solid #2a3f5f; border-radius: 5px; background: #0e111a; color: #e0e6ed; }
    button { background: #5cc8ff; color: #0e111a; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold; margin: 3px; font-size: 12px; }
    button:hover { background: #1a9fff; }
    button.passed { background: #4caf50; }
    #map { width: 100%; height: 600px; border-radius: 10px; margin-bottom: 20px; }
    .info-panel { background: #1a1f2e; padding: 15px; border-radius: 10px; margin-bottom: 20px; }
    .player-info { background: #0e111a; padding: 10px; margin: 10px 0; border-radius: 5px; border-left: 4px solid #5cc8ff; }
    .estimated { color: #ff9800; }
    .actual { color: #4285f4; }
    .checkpoint-controls { background: #1a1f2e; padding: 20px; border-radius: 10px; margin-bottom: 20px; }
    .checkpoint-item { display: flex; align-items: center; gap: 10px; margin: 10px 0; padding: 10px; background: #0e111a; border-radius: 5px; }
    .checkpoint-item label { margin: 0; flex: 0 0 120px; }
    .checkpoint-item input { width: 150px; }
    .checkpoint-item button { flex: 0 0 100px; }
    table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    table td { padding: 8px; border-bottom: 1px solid #2a3f5f; }
    table td:first-child { font-weight: bold; color: #5cc8ff; }
  </style>
  <script type="text/javascript" src="https://oapi.map.naver.com/openapi/v3/maps.js?ncpKeyId=04ebpnqto6"></script>
</head>
<body>
  <div class="container">
    <h1>ğŸ“ ì¶˜ì²œë§ˆë¼í†¤ ì˜ˆìƒ ìœ„ì¹˜ í…ŒìŠ¤íŠ¸</h1>
    
    <div class="controls">
      <label>í˜„ì¬ ì‹œê°„ (í…ŒìŠ¤íŠ¸ìš©)</label>
      <input type="datetime-local" id="currentTime" value="2025-10-26T10:30:00">
      
      <button onclick="updateTest()">ìœ„ì¹˜ ì—…ë°ì´íŠ¸</button>
      <button onclick="addMinutes(5)">+5ë¶„</button>
      <button onclick="addMinutes(10)">+10ë¶„</button>
      <button onclick="addMinutes(30)">+30ë¶„</button>
      <button onclick="resetCheckpoints()">ì´ˆê¸°í™”</button>
    </div>

    <div class="checkpoint-controls">
      <h3 style="color: #5cc8ff; margin-top: 0;">ì²´í¬í¬ì¸íŠ¸ í†µê³¼ ì„¤ì •</h3>
      <div id="checkpointList"></div>
    </div>
    
    <div id="info" class="info-panel"></div>
    
    <div id="map"></div>
  </div>

  <script>
    let map = null;
    let markers = new Map();
    let coursePath = null;
    let gpxPoints = [];
    let checkpointMarkers = [];
    
    const checkpoints = [
      { code: "P0", name: "ì¶œë°œ", distance: 0.00 },
      { code: "P2", name: "ë°˜í™˜ì ", distance: 4.00 },
      { code: "P4", name: "5K", distance: 5.00 },
      { code: "P5", name: "10K", distance: 10.00 },
      { code: "P6", name: "15K", distance: 15.00 },
      { code: "P7", name: "20K", distance: 20.00 },
      { code: "P8", name: "Half", distance: 21.10 },
      { code: "P9", name: "25K", distance: 25.00 },
      { code: "P10", name: "30K", distance: 30.00 },
      { code: "P11", name: "35K", distance: 35.00 },
      { code: "P12", name: "40K", distance: 40.00 },
      { code: "P13", name: "ë„ì°©", distance: 42.20 }
    ];
    
    // ê°€ì§œ ì£¼ì ë°ì´í„°
    const playerData = {
      num: "1003",
      name: "í…ŒìŠ¤íŠ¸ ì£¼ì",
      result_nettime: null,
      pace_nettime: "05:48",
      event: { id: 132, name: "2025 ì¶˜ì²œë§ˆë¼í†¤", date: "2025-10-26" },
      course: { distance: "42.195" },
      records: []
    };
    
    function renderCheckpointControls() {
      const container = document.getElementById('checkpointList');
      container.innerHTML = checkpoints.map((cp, idx) => `
        <div class="checkpoint-item">
          <label>${cp.name} (${cp.distance}km)</label>
          <input type="time" id="time_${cp.code}" value="" step="1" placeholder="í†µê³¼ ì‹œê°„">
          <input type="text" id="pace_${cp.code}" value="05:48" placeholder="í˜ì´ìŠ¤" style="width: 80px;">
          <button id="btn_${cp.code}" onclick="passCheckpoint('${cp.code}', ${idx})">í†µê³¼ ì„¤ì •</button>
        </div>
      `).join('');
    }
    
    function passCheckpoint(code, idx) {
      const timeInput = document.getElementById(`time_${code}`);
      const paceInput = document.getElementById(`pace_${code}`);
      const btn = document.getElementById(`btn_${code}`);
      
      if (!timeInput.value) {
        // ìë™ìœ¼ë¡œ í˜„ì¬ ì‹œê°„ ì„¤ì •
        const currentTime = new Date(document.getElementById('currentTime').value);
        timeInput.value = currentTime.toTimeString().slice(0, 8);
      }
      
      const checkpoint = checkpoints[idx];
      const existingIdx = playerData.records.findIndex(r => r.point.distance === checkpoint.distance.toString());
      
      const record = {
        point: { 
          name: checkpoint.name, 
          distance: checkpoint.distance.toFixed(2)
        },
        time_point: timeInput.value
      };
      
      if (existingIdx >= 0) {
        playerData.records[existingIdx] = record;
      } else {
        playerData.records.push(record);
      }
      
      // ë ˆì½”ë“œ ì •ë ¬
      playerData.records.sort((a, b) => parseFloat(a.point.distance) - parseFloat(b.point.distance));
      
      // í˜ì´ìŠ¤ ì—…ë°ì´íŠ¸
      playerData.pace_nettime = paceInput.value;
      
      btn.classList.add('passed');
      btn.textContent = 'âœ“ í†µê³¼ë¨';
      
      updateTest();
    }
    
    function resetCheckpoints() {
      playerData.records = [];
      checkpoints.forEach(cp => {
        const btn = document.getElementById(`btn_${cp.code}`);
        const timeInput = document.getElementById(`time_${cp.code}`);
        btn.classList.remove('passed');
        btn.textContent = 'í†µê³¼ ì„¤ì •';
        timeInput.value = '';
      });
      
      // ë§ˆì»¤ ì œê±°
      markers.forEach(item => {
        if (item.marker) item.marker.setMap(null);
        if (item.label) item.label.setMap(null);
      });
      markers.clear();
      
      updateTest();
    }
    
    function timeToSeconds(t) {
      if (!t) return 0;
      const clean = t.split('.')[0];
      const p = clean.split(':').map(Number);
      if (p.length === 3) return p[0] * 3600 + p[1] * 60 + p[2];
      if (p.length === 2) return p[0] * 60 + p[1];
      return 0;
    }
    
    function calcDistance(lat1, lng1, lat2, lng2) {
      const R = 6371;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLng = (lng2 - lng1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLng / 2) * Math.sin(dLng / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }
    
    function getPositionOnRoute(distanceKm) {
      if (!gpxPoints || gpxPoints.length === 0) return null;
      let accumulated = 0;
      for (let i = 1; i < gpxPoints.length; i++) {
        const prev = gpxPoints[i - 1];
        const curr = gpxPoints[i];
        const segDist = calcDistance(prev.lat(), prev.lng(), curr.lat(), curr.lng());
        if (accumulated + segDist >= distanceKm) {
          const ratio = (distanceKm - accumulated) / segDist;
          const lat = prev.lat() + (curr.lat() - prev.lat()) * ratio;
          const lng = prev.lng() + (curr.lng() - prev.lng()) * ratio;
          return new naver.maps.LatLng(lat, lng);
        }
        accumulated += segDist;
      }
      return gpxPoints[gpxPoints.length - 1];
    }
    
    function estimateNow(currentTime) {
      const dist = parseFloat(playerData.course?.distance || '0');
      const recs = playerData.records.sort((a, b) => parseFloat(a.point.distance) - parseFloat(b.point.distance));
      if (!recs.length) return { status: 'ëŒ€ê¸°', d: 0, name: '', estimated: 0 };
      
      const lastRec = recs[recs.length - 1];
      const d = parseFloat(lastRec.point.distance);
      const name = lastRec.point.name;
      const time = lastRec.time_point;
      const date = playerData.event?.date;
      
      const lastTime = new Date(`${date}T${time}`);
      const now = new Date(currentTime);
      const elapsedSec = (now - lastTime) / 1000;
      
      let estimatedDist = d;
      if (playerData.pace_nettime && elapsedSec > 0 && !playerData.result_nettime) {
        const paceStr = playerData.pace_nettime.split('.')[0];
        const paceSec = timeToSeconds(paceStr);
        if (paceSec > 0) {
          const kmPerSec = 1 / paceSec;  // 1kmë‹¹ paceSecì´ˆ ê±¸ë¦¬ë¯€ë¡œ, 1ì´ˆë‹¹ 1/paceSec km ì´ë™
          const movedKm = kmPerSec * elapsedSec;
          estimatedDist = Math.min(d + movedKm, dist);
        }
      }
      
      return {
        status: playerData.result_nettime ? 'ì™„ì£¼' : 'ì£¼í–‰',
        d,
        name,
        estimated: estimatedDist,
        elapsedSec,
        lastTime
      };
    }
    
    async function loadGPX() {
      try {
        const r = await fetch('/course.gpx');
        const text = await r.text();
        const parser = new DOMParser();
        const xml = parser.parseFromString(text, 'text/xml');
        const trkpts = xml.querySelectorAll('trkpt');
        const path = [];
        trkpts.forEach(pt => {
          const lat = parseFloat(pt.getAttribute('lat'));
          const lon = parseFloat(pt.getAttribute('lon'));
          if (lat && lon) path.push(new naver.maps.LatLng(lat, lon));
        });
        gpxPoints = path;
        
        // ì½”ìŠ¤ ê²½ë¡œ ê·¸ë¦¬ê¸°
        coursePath = new naver.maps.Polyline({
          path: path,
          strokeColor: '#FF0000',
          strokeOpacity: 0.6,
          strokeWeight: 4,
          map: map
        });
        
        const bounds = new naver.maps.LatLngBounds();
        path.forEach(p => bounds.extend(p));
        map.fitBounds(bounds);
        
        // ì²´í¬í¬ì¸íŠ¸ ë§ˆì»¤ í‘œì‹œ
        checkpoints.forEach((cp, idx) => {
          const pos = getPositionOnRoute(cp.distance);
          if (pos) {
            const marker = new naver.maps.Marker({
              position: pos,
              map: map,
              icon: {
                content: `<div style="
                  background: #2a3f5f;
                  color: white;
                  padding: 4px 8px;
                  border-radius: 12px;
                  font-size: 11px;
                  font-weight: bold;
                  border: 2px solid white;
                  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                ">${cp.name}</div>`,
                anchor: new naver.maps.Point(0, 25)
              }
            });
            checkpointMarkers.push(marker);
          }
        });
        
      } catch (e) {
        console.error('Failed to load GPX:', e);
      }
    }
    
    function updateMarker(bib, pos, isEstimated, info) {
      if (markers.has(bib)) {
        const item = markers.get(bib);
        item.marker.setPosition(pos);
        item.label.setPosition(pos);
        const newContent = `<div style="
          background: ${isEstimated ? 'rgba(255,152,0,0.95)' : 'rgba(66,133,244,0.95)'};
          color: white;
          padding: 6px 12px;
          border-radius: 16px;
          font-weight: bold;
          font-size: 13px;
          white-space: nowrap;
          box-shadow: 0 2px 6px rgba(0,0,0,0.3);
          border: 2px solid white;
        ">${playerData.name}${isEstimated ? ' ğŸ“' : ''}</div>`;
        item.label.setIcon({ content: newContent, anchor: new naver.maps.Point(0, 30) });
      } else {
        const marker = new naver.maps.Marker({
          position: pos,
          map: map,
          icon: {
            content: `<div style="width:12px;height:12px;background:#5cc8ff;border:3px solid #fff;border-radius:50%;box-shadow:0 2px 6px rgba(0,0,0,0.3);"></div>`,
            anchor: new naver.maps.Point(9, 9)
          }
        });
        
        const labelContent = `<div style="
          background: ${isEstimated ? 'rgba(255,152,0,0.95)' : 'rgba(66,133,244,0.95)'};
          color: white;
          padding: 6px 12px;
          border-radius: 16px;
          font-weight: bold;
          font-size: 13px;
          white-space: nowrap;
          box-shadow: 0 2px 6px rgba(0,0,0,0.3);
          border: 2px solid white;
        ">${playerData.name}${isEstimated ? ' ğŸ“' : ''}</div>`;
        
        const label = new naver.maps.Marker({
          position: pos,
          map: map,
          icon: { content: labelContent, anchor: new naver.maps.Point(0, 30) }
        });
        
        markers.set(bib, { marker, label });
      }
      
      map.setCenter(pos);
      if (markers.size === 1) map.setZoom(14);
    }
    
    function updateTest() {
      const currentTime = document.getElementById('currentTime').value;
      
      if (playerData.records.length === 0) {
        document.getElementById('info').innerHTML = `
          <div class="player-info">
            <h3>${playerData.name}</h3>
            <p style="color: #ff9800;">ì²´í¬í¬ì¸íŠ¸ë¥¼ í†µê³¼ ì„¤ì •í•˜ì„¸ìš”.</p>
          </div>
        `;
        return;
      }
      
      const est = estimateNow(currentTime);
      const pos = getPositionOnRoute(est.estimated);
      
      if (!pos) {
        alert('GPX ë¡œë”© ì¤‘ì…ë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
        return;
      }
      
      // í•­ìƒ íŒŒë€ìƒ‰ìœ¼ë¡œ í‘œì‹œ (ì˜ˆìƒ ìœ„ì¹˜ ê³„ì‚° ì¤‘)
      updateMarker(playerData.num, pos, false, est);
      
      // ì •ë³´ íŒ¨ë„ ì—…ë°ì´íŠ¸
      const info = document.getElementById('info');
      info.innerHTML = `
        <div class="player-info">
          <h3>${playerData.name} (#${playerData.num})</h3>
          <table>
            <tr><td>ë§ˆì§€ë§‰ í†µê³¼</td><td>${est.name} (${est.d}km) - ${est.lastTime.toLocaleTimeString()}</td></tr>
            <tr><td>í˜„ì¬ ì‹œê°„</td><td>${new Date(currentTime).toLocaleTimeString()}</td></tr>
            <tr><td>ê²½ê³¼ ì‹œê°„</td><td>${Math.floor(est.elapsedSec / 60)}ë¶„ ${Math.floor(est.elapsedSec % 60)}ì´ˆ</td></tr>
            <tr><td>í˜ì´ìŠ¤</td><td>${playerData.pace_nettime}/km</td></tr>
            <tr><td class="actual">ğŸ“ ì˜ˆìƒ ìœ„ì¹˜</td><td class="actual">${est.estimated.toFixed(2)}km ${est.estimated > est.d ? `(+${(est.estimated - est.d).toFixed(2)}km)` : ''}</td></tr>
          </table>
          <h4 style="color: #5cc8ff; margin-top: 15px;">í†µê³¼ ê¸°ë¡:</h4>
          <table>
            ${playerData.records.map(r => 
              `<tr><td>${r.point.name}</td><td>${r.point.distance}km - ${r.time_point}</td></tr>`
            ).join('')}
          </table>
        </div>
      `;
    }
    
    function addMinutes(min) {
      const input = document.getElementById('currentTime');
      const current = new Date(input.value);
      current.setMinutes(current.getMinutes() + min);
      
      // ë¡œì»¬ ì‹œê°„ìœ¼ë¡œ í¬ë§· (YYYY-MM-DDTHH:MM) - toISOString()ì€ UTCë¡œ ë³€í™˜ë˜ì–´ 9ì‹œê°„ ì°¨ì´ ë°œìƒ
      const year = current.getFullYear();
      const month = String(current.getMonth() + 1).padStart(2, '0');
      const day = String(current.getDate()).padStart(2, '0');
      const hours = String(current.getHours()).padStart(2, '0');
      const minutes = String(current.getMinutes()).padStart(2, '0');
      input.value = `${year}-${month}-${day}T${hours}:${minutes}`;
      
      updateTest();
    }
    
    // ì´ˆê¸°í™”
    window.onload = async () => {
      map = new naver.maps.Map('map', {
        center: new naver.maps.LatLng(37.878, 127.73),
        zoom: 13
      });
      
      await loadGPX();
      renderCheckpointControls();
      updateTest();
    };
  </script>
</body>
</html>
